function [binaryMap2] = segmentAndTrack(videoFile, tau1, alpha, tau2) 
% This function ...
% tau1 is the threshold for the change detection
% alpha is the parameter to weight the contribution of current image and
% previous background in the running average
% tau2 is the threshold for the image differencing in the running average
% Add here input parameters to control the tracking procedure if you need...

% Create a VideoReader object
videoReader = VideoReader(videoFile);
numFrames = ceil(videoReader.Duration * videoReader.FrameRate);
trajectory = cell(1, numFrames-1380);


%i = 0;

%while hasFrame(videoReader)
%        frame = readFrame(videoReader);
%        I_ref = double(rgb2gray(frame));
%        break;
%end

%background_actual = I_ref;

%I_t_prev = I_ref;

% Imposta il frame di partenza desiderato
frameDiPartenza = 1370; 

% Sposta il "cursore" del video al tempo corrispondente
videoReader.CurrentTime = (frameDiPartenza - 1) / videoReader.FrameRate; 

% Inizializza l'indice i al valore corretto
i = frameDiPartenza; 

% Inizializza anche I_t_prev e background_actual leggendo il frame attuale
% altrimenti le operazioni di differenza daranno errore
frameIniziale = readFrame(videoReader);
I_t_prev = double(rgb2gray(frameIniziale));
background_actual = I_t_prev;

% Loop through each frame of the video
while hasFrame(videoReader) && i <= 1450
    % Read the next frame
    frame = readFrame(videoReader);
    I_t = double(rgb2gray(frame));

    binaryMap = abs(I_t - background_actual) > tau1;

    % Update the running average and perform change detection

    mask = abs(I_t - I_t_prev) <= tau2;
    background_actual(mask) = (1 - alpha) * background_actual(mask) + alpha * I_t(mask);

    if(i == 1380)
        pause(5);

    binaryMap2 = binaryMap;
        % In this frame there is a person wearing in white, this is the
        % target you must track
        % Pick a point manually on the person to initialize your trajectory

        stat = regionprops(binaryMap, "Area", "Centroid");
        aree = [stat.Area];
        [~, index] = max(aree);
        c = stat(index).Centroid;

        trajectory{i-1379} = c;

        disp(c);

     

    elseif(i > 1380)

        % * Perform change detection and update the background model
        % * Identify the connected components in the binary map using the
        %   Matlab function bwconncomp

        connected = bwconncomp(binaryMap);

        % * Extract a description for each connected component using the
        %   Matlab function regionprops

        props = regionprops(connected, "Area", "Centroid");

        % 2. Estrai tutte le aree in un vettore numerico
        aree = [props.Area];
        
        % 3. Crea un indice logico per le aree maggiori di 30
        indiceFiltro = aree > 30;
        
        % 4. Applica il filtro alla struttura originale
        propsFiltrati = props(indiceFiltro);
        
        centr_prev = trajectory{i-1380};

        % 2. Estrai tutti i centroidi dei candidati in una matrice [N x 2]
        tuttiICentroidi = cat(1, propsFiltrati.Centroid);
        
        % 3. Calcola la distanza Euclidea tra il target e ogni candidato
        % (x2-x1)^2 + (y2-y1)^2
        differenze = tuttiICentroidi - centr_prev;
        distanze = sqrt(sum(differenze.^2, 2));
        
        % 4. Trova l'indice del centroide con la distanza minima
        [~, idxVicino] = min(distanze);
        
        % 5. Seleziona il nuovo centroide per aggiornare la traiettoria
        nuovoCentroide = tuttiICentroidi(idxVicino, :);

        trajectory{i-1379} = nuovoCentroide;

        disp(nuovoCentroide);



        % * Now you have the positions of all connected components observed
        %   in the current frame and you can associate the target to its new
        %   position --> Append the new position to the trajectory

    end

    % Display the frame
    figure(1), subplot(2, 1, 1), imshow(frame, 'Border', 'tight');
    title(sprintf('Frame %d', round(videoReader.CurrentTime * videoReader.FrameRate)));
    if(i>1380)
        hold on;
        p = trajectory{i-1379};  
        plot(p(1), p(2), '*r');
    end

    % Display the binary map obtained with the static background
    figure(1), subplot(2, 1, 2), imshow(binaryMap, 'Border', 'tight');
    title('Binary map 1');
    if(i>1380)
        hold on;
        p = trajectory{i-1379};
        plot(p(1), p(2), '*r');
    end

    %Display the running average
    %figure(1), subplot(2, 3, 3), imshow(uint8(background_actual), 'Border', 'tight');
    %title('Running average');

    i = i + 1;

    pause(0.5);

end

 % * At the end of the video, visualize the trajectory in the last
 %   frame

% Close the figure when playback is finished
%close all;

fprintf('Finished displaying video: %s\n', videoFile);
end